### JVM垃圾回收机制

1、在JDK1.2之前，使用的是引用计数器算法，即当这个类被加载到内存以后，就会产生方法区，堆栈、程序计数器等一系列信息，当创建对象的时候，为这个对象在堆栈空间中分配对象，同时会产生一个引用计数器，同时引用计数器+1，当有新的引用的时候，引用计数器继续+1，而当其中一个引用销毁的时候，引用计数器-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了！这种算法在JDK1.2之前的版本被广泛使用，但是随着业务的发展，很快出现了一个问题

当我们的代码出现下面的情形时，该算法将无法适应

a\)ObjA.obj = ObjB

b\)ObjB.obj - ObjA

这样的代码会产生如下引用情形 objA指向objB，而objB又指向objA，这样当其他所有的引用都消失了之后，objA和objB还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。

![](http://dl.iteye.com/upload/attachment/0075/0380/c81a6899-507b-3052-8cd5-6345dbb9110a.jpg)

2、根搜索算法

根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。

![](http://dl.iteye.com/upload/attachment/0075/0382/5669793f-fa43-39a8-bec5-cff5eb8bcf46.jpg)

目前java中可作为GC Root的对象有

1、虚拟机栈中引用的对象（本地变量表）

2、方法区中静态属性引用的对象

3、方法区中常量引用的对象

4、本地方法栈中引用的对象（Native对象）

说了这么多，其实我们可以看到，所有的垃圾回收机制都是和引用相关的，那我们来具体的来看一下引用的分类，到底有哪些类型的引用？每种引用都是做什么的呢？



Java中存在四种引用，每种引用如下：

1、强引用

只要引用存在，垃圾回收器永远不会回收

Object obj = new Object\(\);

//可直接通过obj取得对应的对象如obj.equels\(new Object\(\)\);

而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。

2、软引用

非必须引用，内存溢出之前进行回收，可以通过以下代码实现

Object obj = new Object\(\);

SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;\(obj\);

obj = null;

sf.get\(\);//有时候会返回null

这时候sf是对obj的一个软引用，通过sf.get\(\)方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；  
软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。

3、弱引用

第二次垃圾回收时回收，可以通过如下代码实现

Object obj = new Object\(\);

WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;\(obj\);

obj = null;

wf.get\(\);//有时候会返回null

wf.isEnQueued\(\);//返回是否被垃圾回收器标记为即将回收的垃圾

弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。

弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器

4、虚引用（幽灵/幻影引用）

垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现

Object obj = new Object\(\);

PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;\(obj\);

obj=null;

pf.get\(\);//永远返回null

pf.isEnQueued\(\);//返回从内存中已经删除

虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。

虚引用主要用于检测对象是否已经从内存中删除。

每个Java程序员迟早都会碰到下面这个错误：

* **java.lang.OutOfMemoryError**

这个时候一般会建议采用如下方式解决这个错误：

* 增加MaxPermSize值
* 增加最大堆内存到512M（-xmx参数）

这篇文章会具体介绍Java堆空间和参数MaxPermSize的含义。这篇文章涉及下列主题，并采用Hotspot JVM：

* 垃圾回收器（Garbage Collector，GC）
* 哪个
  [JVM?](http://xmlandmore.blogspot.com/2012/08/which-jvm.html)
* JVM命令行选项

**垃圾回收器**

垃圾回收器负责：

* 分配内存
* 保证所有正在被引用的对象还存在于内存中
* 回收执行代码已经不再引用的对象所占的内存

应用执行时，定位和回收垃圾对象的过程会占用总执行时间的将近25%，这会拖累应用的执行效率。

[![](http://www.importnew.com/wp-content/uploads/2012/12/1.jpg "JVM Generational GC")](http://www.importnew.com/1551.html/1-3)

Hotspot VM提供的垃圾回收器是一个分代垃圾回收器（Generational GC）\[9,16,18\]-将内存划分为不同的阶段，也就是说，不同的生命周期的对象放置在不同的地址池中。这样的设计是基于弱年代假设（Weak Generational Hypothesis）：

1.越早分配的对象越容易失效；

2.老对象很少会引用新对象。

这种分代方式可以减少垃圾回收的停顿时间以及大范围对象的回收成本。Hotspot VM将其堆空间分为三个分代空间：

1.**年轻代**（**Young Generation**）

○     Java应用在分配Java对象时，这些对象会被分配到年轻代堆空间中去

○     这个空间大多是小对象并且会被频繁回收

○     由于年轻代堆空间的垃圾回收会很频繁，因此其垃圾回收算法会更加重视回收效率

2.**年老代**（**Old Generationn**）

○     年轻代堆空间的长期存活对象会转移到（也许是永久性转移）年老代堆空间

○     这个堆空间通常比年轻代的堆空间大，并且其空间增长速度较缓

○     由于大部分JVM堆空间都分配给了年老代，因此其垃圾回收算法需要更节省空间，此算法需要能够处理低垃圾密度的堆空间

3.**持久代**（**Permanent Generation**）

○     存放VM和Java类的元数据（metadata），以及interned字符串和类的静态变量

**次收集（Minor GC）和全收集（Full GC）**

当这三个分代的堆空间比较紧张或者没有足够的空间来为新到的请求分配的时候，垃圾回收机制就会起作用。有两种类型的垃圾回收方式：次收集和全收集。当年轻代堆空间满了的时候，会触发次收集将还存活的对象移到年老代堆空间。当年老代堆空间满了的时候，会触发一个覆盖全范围的对象堆的全收集。

**次收集**

* 当年轻代堆空间紧张时会被触发
* 相对于全收集而言，收集间隔较短

**全收集**

* 当老年代或者持久代堆空间满了，会触发全收集操作
* 可以使用System.gc\(\)方法来显式的启动全收集
* 全收集一般根据堆大小的不同，需要的时间不尽相同，但一般会比较长。不过，如果全收集时间超过3到5秒钟，那就太长了\[1\]

全收集通常时间最长，并且是程序无法延迟执行或者无法达到吞吐量目标的主因。GC的目标是去减少程序运行过程中垃圾回收的频率。为了达到这个目的，可以从这两方面入手：

* 从系统方面考虑：

○    尽量采用大堆，但是不要大到需要系统从磁盘上“换”页。一般而言，可用的RAM\(没有被系统进程占用的\)的80%都应该分配给JVM。

○    Java堆空间越大，垃圾回收器和java应用在吞吐量（_throughput_）和延迟执行（_latency_）方面的效果越好。

* 从应用方面考虑：

○    减少对象分配（_object allocations_）操作，或者采用对象保留（_object retention_）方式有助于减小存活的数据大小，这也可以反过来帮助垃圾回收做的更好。

○    参考这篇文章—Java性能提升窍门\[19\]

**内存溢出错误（OutOfMemoryError）**

可怕的内存溢出错误是Java程序员最不愿意看到的。然而这个错误还是会出现，尤其应用中涉及到大量的数据处理时，或应用运行时间过长时。

一个应用所占内存大小包括：

* Java堆大小
* 线程栈
* I/O缓冲区
* 原生库所分配的内存

当一个应用耗尽了内存并且JVM GC也无法回收任何对象空间的时候，就会发生内存溢出错误。但是，内存溢出错误并不一定就意味着内存泄露（memory leak）。也有可能只是一个配置问题，例如设置的堆大小（如果没有设置那就是缺省的堆大小）对于应用来说是不够用的。

**JVM命令行参数**

无论是客户端应用还是服务器端应用，一旦系统运行缓慢并且垃圾回收所占时间过长，你就会希望通过调整堆大小来改善这一点。不过，为了不影响其他也跑在同一个系统中的应用，不应该将堆大小设置的过大。

GC调优是很重要的。找到最佳的分代堆空间是一个迭代的过程\[3,10,12\]。这里我们假定你已经为你的应用找到了最佳堆大小。那么你可以采用下面的JVM命令来进行设置：

[![](http://www.importnew.com/wp-content/uploads/2012/12/2.jpg "JVM command")](http://www.importnew.com/1551.html/2-2)

| **GC命令行选项** | **描述** |
| :--- | :--- |
| -Xms | 设置Java堆大小的初始值/最小值。例如：-Xms512m \(请注意这里没有”=”\). |
| -Xmx | 设置Java堆大小的最大值 |
| -Xmn | 设置年轻代对空间的初始值，最小值和最大值。请注意，年老代堆空间大小是依赖于年轻代堆空间大小的 |
| -XX:PermSize=&lt;n&gt;\[g\|m\|k\] | 设置持久代堆空间的初始值和最小值 |
| -XX:MaxPermSize=&lt;n&gt;\[g\|m\|k\] | 设置持久代堆空间的最大值 |

最后一点，最早在Java SE 5.0中有对服务器的人机工程学的介绍\[13\]。这个可以很好的减少服务器端应用的调优时间，尤其是在堆大小测量和复杂GC调优方面。很多情况下，服务器端调优的最好方式就是不去调优。

![](/assets/jvmgc1.png)![](/assets/jvmgc2.png)

