### JVM垃圾回收机制

1、在JDK1.2之前，使用的是引用计数器算法，即当这个类被加载到内存以后，就会产生方法区，堆栈、程序计数器等一系列信息，当创建对象的时候，为这个对象在堆栈空间中分配对象，同时会产生一个引用计数器，同时引用计数器+1，当有新的引用的时候，引用计数器继续+1，而当其中一个引用销毁的时候，引用计数器-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了！这种算法在JDK1.2之前的版本被广泛使用，但是随着业务的发展，很快出现了一个问题

当我们的代码出现下面的情形时，该算法将无法适应

a\)ObjA.obj = ObjB

b\)ObjB.obj - ObjA

这样的代码会产生如下引用情形 objA指向objB，而objB又指向objA，这样当其他所有的引用都消失了之后，objA和objB还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。



  
![](http://dl.iteye.com/upload/attachment/0075/0380/c81a6899-507b-3052-8cd5-6345dbb9110a.jpg)



2、根搜索算法

根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。



  


![](http://dl.iteye.com/upload/attachment/0075/0382/5669793f-fa43-39a8-bec5-cff5eb8bcf46.jpg)

  




目前java中可作为GC Root的对象有

1、虚拟机栈中引用的对象（本地变量表）

2、方法区中静态属性引用的对象

3、方法区中常量引用的对象

4、本地方法栈中引用的对象（Native对象）

说了这么多，其实我们可以看到，所有的垃圾回收机制都是和引用相关的，那我们来具体的来看一下引用的分类，到底有哪些类型的引用？每种引用都是做什么的呢？

Java中存在四种引用，每种引用如下：

1、强引用

只要引用存在，垃圾回收器永远不会回收

Object obj = new Object\(\);

//可直接通过obj取得对应的对象如obj.equels\(new Object\(\)\);

而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。

2、软引用

非必须引用，内存溢出之前进行回收，可以通过以下代码实现

Object obj = new Object\(\);

SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;\(obj\);

obj = null;

sf.get\(\);//有时候会返回null

这时候sf是对obj的一个软引用，通过sf.get\(\)方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；  
软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。

3、弱引用

第二次垃圾回收时回收，可以通过如下代码实现

Object obj = new Object\(\);

WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;\(obj\);

obj = null;

wf.get\(\);//有时候会返回null

wf.isEnQueued\(\);//返回是否被垃圾回收器标记为即将回收的垃圾

弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。

弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器

4、虚引用（幽灵/幻影引用）

垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现

Object obj = new Object\(\);

PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;\(obj\);

obj=null;

pf.get\(\);//永远返回null

pf.isEnQueued\(\);//返回从内存中已经删除

虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。

虚引用主要用于检测对象是否已经从内存中删除。



