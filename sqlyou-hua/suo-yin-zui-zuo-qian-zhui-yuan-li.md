假设数据 表T \(a,b,c\) rowid 为物理位置

rowid a b c

\(1\) 1 1 1

\(2\) 2 1 13

\(3\) 2 2 14

\(4\) 1 3 3

\(5\) 2 3 12

\(6\) 1 2 5

\(7\) 2 3 9

\(8\) 1 2 2

\(9\) 1 3 6

\(10\) 2 2 11

\(11\) 2 2 8

\(12\) 1 1 7

\(13\) 2 3 15

\(14\) 1 1 4

\(15\) 2 1 10

当你创建一个索引 create index xxx on t\(a,b\), 则索引文件逻辑上等同于如下

a b rowid

1 1 1

1 1 12

1 1 14

1 2 6

1 2 8

1 3 4

1 3 9

2 1 2

2 1 15

2 2 3

2 2 10

2 2 11

2 3 5

2 3 7

2 3 13

当select \* from T where a=1 and b=3 的时候， 数据库系统可以直接从索引文件中直接二分法找到A=1的记录，然后再B=3的记录。

但如果你 where b=3 则需要遍历这个索引表的全部！



B-tree，B是balance，一般用于[**数据库**](https://www.2cto.com/database/)**的索引**。使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。而B+tree是B-tree的一个变种，大名鼎鼎的MySQL就普遍使用B+tree实现其索引结构。

　　那数据库为什么使用这种结构？

　　一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

　　为了达到这个目的，磁盘按需读取，要求每次都会预读的长度一般为页的整数倍。而且数据库[系统](https://www.2cto.com/os/)将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。并把B-tree中的m值设的非常大，就会让树的高度降低，有利于一次完全载入

